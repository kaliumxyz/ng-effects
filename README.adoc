:toc:
:toc-placement!:

image::https://i.imgur.com/A1924dn.png[Angular Effects]

== Angular Effects

Reactive extensions for Angular.

[source,typescript]
----
@Component({
    selector: "app-root",
    template: `
        <div>Count: {{count}}</div>
    `,
    providers: [Effects],
})
export class AppComponent {
    @Input()
    count: number = 0

    constructor(connect: Connect) {
        connect(this)
    }

    @Effect("count")
    incrementCount(state: State<AppState>) {
        return state.count.pipe(
            take(1),
            increment(1),
            repeatInterval(1000)
        )
    }
}
----

=== Links

link:./docs/announcement.adoc[Read the announcement]

== Installation

Install via NPM.

[source,bash]
----
npm install ng-effects
----

== Table of contents

:toc-title:

toc::[]

== Usage

=== Initialize effects

First add `Effects` to providers, then inject `Connect` and call it from the constructor. To avoid errors, ensure that properties are initialized before calling `connect()`. Declare your effects by decorating them with `@Effect()`

[source,typescript]
----
@Component({
    providers: [Effects]
})
export class AppComponent {
    count = 0

    constructor(connect: Connect) {
        connect(this) // Should always be called in the constructor
    }

    @Effect(options)
    myAwesomeEffect() {
        // Return an observable, subscription or teardown function
    }
}
----

=== Effect options

Effects are configured through the decorator with a number of options.

|===
|Option |Type |Description

|bind
|string
|When configured, maps values emitted by the effect to a property of the same name on the host context. Throws an error when trying to bind to an uninitialised property.

|assign
|boolean
|When configured, assigns the properties of partial objects emitted by the effect to matching properties on the host context. Throws an error when trying to bind to any uninitialised properties.

|markDirty
|boolean
|When set to true, schedule change detection to run whenever a bound effect emits a value.

Default: `true` if `bind` or `apply` is set.

|detectChanges
|boolean
|When set to true, detect changes immediately whenever a bound effect emits a value. Takes precendence over `markDirty`.

|whenRendered
|boolean
|When set to true, the effect deferred until the host element has been mounted to the DOM.

Default: `false`

|adapter
|Type<EffectAdapter>
|Hook into effects with a custom link:#effect_adapters[effect adapter]. For example, dispatching actions to NgRx or other global state stores.
|===

==== Default options

Default options can be configured with the `effects()` provider.

[source,typescript]
----
@NgModule({
    providers: [
        effects({
            markDirty: true,
            whenRendered: true,
            detectChanges: false
        })
    ]
})
export class AppModule {}
----

=== Host effects

Effects declared directly on a component or directive are host effects. For effects to run, add `Effects` to your providers array. This token must be provided separetely in every component or directive that has effects.

[source,typescript]
----
@Component({
    providers: [Effects]
})
export class AppComponent implements AppState {
    count = 0

    constructor(connect: Connect) {
        connect(this)
    }

    @Effect()
    logCount(state: State<AppState>) {
        return state.count.subscribe(count => console.log(count))
    }
}
----

=== Effect services

Effects can be extracted and reused through injectable services. These must be provided in each component that uses them. Effects are not inherited from parents.

[source,typescript]
----
@Injectable()
export class AppEffects {
    @Effect("count")
    incrementCount(state: State<AppState>) {
        return state.count.pipe(
            take(1),
            increment(1),
            repeatInterval(1000)
        )
    }
}

@Injectable()
export class OtherEffects {
    // etc...
}

@Component({
    selector: "app-root",
    template: `
        <div>Count: {{count}}</div>
    `,
    providers: [Effects, AppEffects, OtherEffects],
})
export class AppComponent implements AppState {
    count = 0

    constructor(connect: Connect) {
        connect(this)
    }
}
----

== Examples

=== Special injection tokens

Injected services share the same injector scope as their host. Special tokens such as `ElementRef` and `Renderer2` can be injected.

[source,typescript]
----
@Injectable()
export class AppEffects {
    constructor(private elementRef: ElementRef, private renderer: Renderer2) {}
}
----

==== HostRef

A reference to the host component or directive can be injected using the `HostRef<T>` token. Each effect is passed arguments with the same values as this token.

[source,typescript]
----
@Injectable()
export class AppEffects {
    context: AppComponent
    state: State<AppComponent>
    observer: Observable<AppComponent>

    constructor(hostRef: HostRef<AppComponent>) {
        this.context = hostRef.context
        this.state = hostRef.state
        this.observer = hostRef.observer
    }
}
----

The parent context can be injected using `SkipSelf()`

[source,typescript]
----
@Injectable()
export class ChildEffects {
    constructor(@SkipSelf() parent: HostRef<ParentComponent>) {}
}
----

===== context

A reference to the component or directive instance.

===== state
A reference to the _observable state_ of the component or directive. Properties on this object are not populated unless they have been initialized in the host context constructor before calling `connect()`. Deferred properties such as view children are attached  after the component has rendered.

===== observer
Analagous to `DoCheck`, except observable. Emits very frequently. Useful for custom change detection strategies or debugging.

=== Property bindings

Effects can be bound a named property on the host by setting the `bind` property. This property is updated whenever the effect emits a new value. Throws an error if the bound property is not initialized.

[source,typescript]
----
@Injectable()
export class AppEffects {
    @Effect("count")
    incrementCount(state: State<AppState>) {
        return state.count.pipe(
            take(1),
            increment(1),
            repeatInterval(1000)
        )
    }
}
----

=== Multiple bindings

Multiple effects can be bound to the same property.

[source,typescript]
----
@Component()
export class AppComponent implements AppState {
    count: number

    @Effect("count")
    incrementCount(state: State<AppState>) {
        // implementation
    }

    @Effect("count")
    multiplyCount(state: State<AppState>) {
        // implementation
    }
}
----

=== Partial bindings

If the effect should update multiple properties on the host context at the same time, use the `assign` option. Throws an error if any emitted properties are not initialised on the host.

[source,typescript]
----
@Component()
export class AppComponent implements AppState {
    @Effect({ assign: true })
    assignMany(state: State<AppState>) {
        return of({
            prop1: "value1",
            prop2: "value2"
        })
    }
}
----

=== Side effects

Effects that do not bind a property can return an observable or subscription/teardown function to perform side effects.

[source,typescript]
----
@Injectable()
export class AppEffects {
    @Effect()
    logCountWithObservable(state: State<AppState>) {
        return state.count.pipe(
            tap(count => console.log(count))
        )
    }

    @Effect()
    logCountWithSubscription(state: State<AppState>) {
        return state.count.subscribe(count => console.log(count))
    }

    @Effect()
    logCountWithTeardown(state: State<AppState>) {
        const sub = state.count.subscribe(count => console.log(count))
        return function () {
            sub.unsubscribe()
        }
    }
}
----

=== Output bindings

Effects can be connected to host outputs.

[source,typescript]
----
@Component({
    providers: [Effects]
})
export class AppComponent {
    count: number

    @Output()
    countChange: EventEmitter<number>

    @Effect()
    onCountChange(state: State<AppComponent>, context: Context<AppComponent>) {
        return changes(state.count).subscribe(context.countChange)
    }
}
----

=== Template event bindings

Use event emitters to capture template events and make them observable. `HostEmitter` is a special subject that can be invoked as a function. It's value also stays unwrapped in `State` for convenience.

[source,typescript]
----
@Component({
    template: `<div (click)="clicked($event)">Click me<div>`,
    providers: [Effects]
})
export class AppComponent {
    clicked = new HostEmitter<MouseEvent>()

    constructor(connect: Connect) {
        connect(this)
    }

    @Effect()
    handleTemplateClick(state: State<AppComponent>) {
        return state.clicked.subscribe(
            event => console.log(`click:`, event)
        )
    }
}
----

=== Host listener bindings

Use `HostEmitter` to bind `HostListener` properties. `HostEmitter` is a special subject that can be invoked as a function. It's value also stays unwrapped in `State` for convenience.

[source,typescript]
----
@Component({
    providers: [Effects],
})
export class AppComponent {
    @HostListener("click", ["$event"])
    clicked = new HostEmitter<MouseEvent>()

    constructor(connect: Connect) {
        connect(this)
    }

    @Effect()
    handleClick(state: State<AppComponent>) {
        return state.clicked.subscribe((event) => {
            console.log("clicked", event)
        })
    }
}
----

=== Query bindings

All component queries (`ViewChild`, `ViewChildren`, `ContentChild`, `ContentChildren`) can be observed from `State`. Defer effects that use these values with `whenRendered: true` for best results.

[source,typescript]
----
@Component({
    selector: "app-child",
    template: `
        <app-child>Projected</app-child>
    `,
    providers: [Effects, ChildEffects],
})
export class ChildComponent {
    @ViewChild(ChildComponent)
    viewChild: ChildComponent

    constructor(connect: Connect) {
        connect(this)
    }

    @Effect({ whenRendered: true })
    withViewChild(state: State<ChildComponent>) {
        return state.viewChild.subscribe(viewChild => {
            console.log(viewChild)
        })
    }
}
----

=== DOM manipulation

Effects can be deferred until after the component has been rendered to the DOM tree. Combine with teardown logic to perform any DOM cleanup when the host is destroyed.

[source,typescript]
----
@Injectable()
export class AppEffects {
    constructor(private elementRef: ElementRef) {}

    @Effect({ whenRendered: true })
    mounted(state: State<AppComponent>, context: Context<AppComponent>) {
        const instance = thirdPartyLib.mount(this.elementRef.nativeElement)
        return function () {
            // cleanup logic
        }
    }
}
----

=== Compose multiple observable sources

Observable services can be injected, then composed. For example, compose http services when inputs change, or map global state to local state.

[source, typescript]
----
@Injectable()
export class AppEffects {
    constructor(private http: HttpClient, private store: Store<any>) {}

    @Effect("activeUser")
    selectActiveUser(state: State<AppComponent>) {
        return this.store.pipe(
            select(store => store.activeUser)
        )
    }

    @Effect()
    dispatchForm(state: State<AppComponent>, context: Context<AppComponent>) {
        return context.formData.valueChanges.subscribe(payload => {
            this.store.dispatch({
                type: "FORM_UPDATED",
                payload
            })
        })
    }

    @Effect()
    fetchUsers(state: State<AppComponent>) {
        return changes(state.userId).pipe(
            switchMap(userId => this.http.get<Users>(`https://example.com/users/${userId}`).pipe(
                catchError(error => {
                    console.error(error)
                    return NEVER
                })
            ))
        ).subscribe(state.usersFetched)
    }
}

@Component()
export class AppComponent {
    @Input() userId: string
    @Output() usersFetched: HostEmitter<Users>
    activeUser: User
    formData: FormGroup

    // etc...
}
----

=== Effect adapters

An effect adapter can be passed in to do additional processing after the observable has emitted a value. This can be useful for adding a dispatcher to automatically dispatch actions to a global state store such as NgRx.

[source,typescript]
----
interface DispatchOptions {
    customOption: boolean
}

@Injectable({ providedIn: "root" })
export class Dispatch implements EffectAdapter<Action, DispatchOptions> {
    constructor(private store: Store<any>) {}

    next(action: Action, metadata: EffectMetadata<DispatchOptions>) {
        if (metadata.options.customOption) {
            this.store.dispatch(action)
        }
    }
}
----

[source,typescript]
----
@Injectable()
export class AppEffects {
    @Effect(Dispatch, { customOption: true })
    dispatchAction(state: State<AppComponent>, context: Context<AppComponent>) {
        return context.formData.valueChanges.pipe(
            map(payload => ({
                type: "FORM_UPDATED",
                payload
            }))
        )
    }
}
----

=== Map global state

We can write effect adapters that hook into global state to make selecting values easier.

[source, typescript]
----
type MapStateToProps<T, U> = {
    [key in keyof U]?: (state: T) => U[key]
}

@Injectable({ providedIn: "root" })
export class Select implements EffectAdapter<MapStateToProps<any, any>> {
    constructor(private store: Store<any>) {}

    public create(mapState: MapStateToProps<any, any>, metadata: EffectMetadata) {
        metadata.options.assign = true

        const sources = Object.entries(mapState).map(([prop, selector]) =>
            this.store.pipe(
                select(selector!),
                map(value => ({ [prop]: value })),
            ),
        )

        return merge(...sources)
    }
}

----

This adapter takes a map of selector functions which can be used like this. There's a difference from the previous example; we are transforming the effect instead of observing it.

[source,typescript]
----
interface AppState {
    count: number
}

const selectCount = (state: AppState) => state.count

@Component()
export class AppComponent {
    count = 0

    @Effect(Select)
    public mapStateToProps(): MapStateToProps<AppState, AppComponent> {
        return {
            count: selectSelect,
        }
    }
}
----

=== Custom lifecycle hooks

Effect adapters can be used to implement your own lifecycle hooks, such as `shouldComponentUpdate`. First create the adapter.

[source, typescript]
----
@Injectable()
export class ShouldComponentUpdate implements EffectAdapter<boolean> {
    constructor(private cdr: ChangeDetectorRef) {
        this.cdr.detach()
    }

    next(shouldUpdate: boolean) {
        shouldUpdate ? this.cdr.reattach() : this.cdr.detach()
    }
}
----

Then use it in your components.

[source, typescript]
----
@Component({
    providers: [Effects, ShouldComponentUpdate]
})
export class AppComponent {
    count = 0

    constructor(connect: Connect) {
        connect(this)
    }

    @Effect(ShouldComponentUpdate)
    shouldComponentUpdate(state: State<AppComponent>) {
        return state.count.pipe(
            map(count => count > 30)
        )
    }
}
----

Use this to defer components from rendering before data has loaded, optimise change detection performance, and more.

=== Bi-directional observable state

Through provider mapping observable state can be accessed from parent to child or vice versa.

[source,typescript]
----
@Component({
    providers: [{
        provide: ParentRef,
        useExisting: HostRef
    }, Effects]
})
export class ParentComponent {
    @Input()
    selected?: ChildComponent = undefined

    @ViewChildren(ChildRef)
    children?: QueryList<ChildRef>

    constructor(connect: Connect) {
        connect(this)
    }

    @Effect("selected", { whenRendered: true })
    select(state: State<ParentComponent>) {
        return state.children.pipe(
            mergeAll(),
            mergeMap(child => child.state.select),
        )
    }
}

@Component({
    providers: [{
        provide: ChildRef,
        useExisting: HostRef
    }, Effects],
})
export class ChildComponent {
    @Input()
    selected = false

    @Output()
    @HostListener("click", "this")
    select = new HostEmitter<ChildComponent>()

    constructor(private parentRef: ParentRef, connect: Connect) {
        connect(this)
    }

    @Effect("selected", { whenRendered: true })
    isSelected(state: State<ChildComponent>, context: Context<ChildComponent>) {
        return this.parentRef.state.selected.pipe(
            map(selected => selected === context)
        )
    }
}
----

== Experimental features

These features rely on unstable APIs that could break at any time.

=== Zoneless change detection

Zoneless change detection depends on experimental Ivy renderer features. To enable this feature, add the `USE_EXPERIMENTAL_RENDER_API` provider to your root module.

Zones can be disabled by commenting out or removing the following line in your app's `polyfills.ts`:

```
import "zone.js/dist/zone" // Remove this to disable zones
```

In your `main.ts` file, set ngZone to "noop".

```ts
platformBrowserDynamic()
    .bootstrapModule(AppModule, { ngZone: "noop" }) // set this option
    .catch(err => console.error(err))
```

=== Global connect hook

Global hooks are a new feature in Angular 9.0.0. By using some private APIs we don't have to explicitly inject services to connect components.

[source,typescript]
----
@Component({
    providers: [Effects]
})
export class AppComponent {
    count = 0
    // can omit `Connect`
    constructor() {
        connect(this)
    }

    @Effect("count")
    incrementCount() {
        // etc
    }
}
----

=== Connect API

> Under the hood, this the mechanism that makes effects run. This is not a stable API so use it at your own risk.

If you are familiar with `APP_INITIALIZER`, it's like that except for components and directives. To create a service that is automatically instantiated when the component or directive is "connected" (ie. by calling `connect()`), add a multi provider to your providers array similar to this one.

[source,typescript]
----
@Injectable()
export class MyConnectedService {
    constructor(hostRef: HostRef) {}
}

export const INITIALIZERS = [{
    provide: HOST_INITIALIZER,
    useValue: MyConnectedService,
    multi: true
}]

export const CONNECTED = [
    MyConnectedService,
    CONNECT,
    INITIALIZERS
]

@Component({
    providers: [CONNECTED]
})
export class MyComponent {
    constructor(connect: Connect) {
        connect(this)
    }
}
----

When the component is created in this example, `MyConnectedService` will be instantiated and have access to the `HostRef`.
